---
description:
globs:
alwaysApply: true
---

# Job Hunt Automation - Cursor Rules

## Project Overview

This is a TypeScript/Deno job hunt automation system that uses AI to analyze job postings, generate
tailored application materials, and organize data in Google Sheets. The project follows functional
programming patterns with clear separation of concerns.

## Language & Runtime

- **Language**: TypeScript with strict typing
- **Runtime**: Deno (not Node.js)
- **Module System**: ES modules with explicit `.ts` extensions
- **Import Style**: Use explicit file extensions in imports (e.g., `"./types.ts"`)

## Code Style & Patterns

### Function Declarations

- Use `function` keyword for all function declarations (not arrow functions)
- Prefer named exports over default exports
- Use descriptive function names with auxiliary verbs (e.g., `analyzeJobRelevance`,
  `generateTailoredResume`)

### TypeScript Usage

- Use interfaces over types for object shapes
- Avoid enums; use const objects with `as const` instead
- Always provide explicit return types for functions
- Use strict type checking and avoid `any` type

### Error Handling

- Use try-catch blocks for external API calls
- Provide meaningful error messages
- Log errors with `console.error()` for debugging
- Throw descriptive errors with context

### Async/Await Patterns

- Use async/await consistently (avoid .then() chains)
- Handle Promise rejections properly
- Use `Promise.all()` for concurrent operations when appropriate
- Implement rate limiting for external API calls

## Project Structure Patterns

### File Organization

```
src/
‚îú‚îÄ‚îÄ business/           # Core business logic
‚îú‚îÄ‚îÄ integration/        # External service integrations
‚îú‚îÄ‚îÄ utils/              # Utility functions
‚îú‚îÄ‚îÄ types.ts            # Type definitions
‚îú‚îÄ‚îÄ index.ts            # Main entry point
‚îî‚îÄ‚îÄ cron.ts             # Cron job scheduler
```

### Naming Conventions

- **Files**: kebab-case for directories and files
- **Functions**: camelCase with descriptive names
- **Constants**: UPPER_SNAKE_CASE
- **Interfaces**: PascalCase with descriptive names
- **Variables**: camelCase with descriptive names

## Integration Patterns

### External APIs

- Create dedicated integration modules in `src/integration/`
- Use environment variables for configuration
- Implement rate limiting for API calls
- Handle API errors gracefully with fallbacks

### Google Services

- Use official Google APIs (googleapis, @google/genai)
- Implement proper authentication with service accounts
- Handle quota limits and rate limiting
- Use structured error handling for API responses

### File System Operations

- Use Node.js fs module with Deno compatibility
- Create directories recursively when needed
- Use JSON.stringify with proper formatting (null, 2)
- Handle file read/write errors explicitly

## Business Logic Patterns

### AI Integration

- Use structured prompts with clear instructions
- Validate AI responses before using them
- Implement retry logic for failed requests
- Use rate limiting to respect API quotas

### Data Processing

- Process data in batches for large datasets
- Use functional programming patterns (map, filter, reduce)
- Implement proper data validation
- Sort results by relevance scores

## Configuration & Environment

### Environment Variables

- Use descriptive variable names
- Validate required environment variables on startup
- Use Deno.env.get() for environment access
- Provide clear error messages for missing variables

### Constants

- Define global scoped constants in `src/utils/constants.ts`
- Use meaningful constant names
- Group related constants together
- Export constants for reuse across modules

## Error Handling & Logging

### Logging Strategy

- Use console.log() for informational messages
- Use console.error() for errors
- Include emojis for visual distinction (‚úÖ, ‚ùå, üîç, üìù)
- Log progress and completion status

### Error Recovery

- Implement graceful degradation
- Provide fallback values when possible
- Continue processing other items when one fails
- Log errors but don't crash the entire process

## Performance & Optimization

### Rate Limiting

- Implement proper rate limiting for external APIs
- Use delays between batch operations
- Respect API quotas and limits
- Process data in manageable chunks

### Memory Management

- Avoid loading large datasets into memory
- Process data streams when possible
- Clean up resources properly

### Code Quality

- Use Deno fmt for code formatting
- Use Deno lint for code linting
- Follow consistent indentation (2 spaces)
- Keep functions focused and single-purpose

## Data Patterns

### Type Definitions

- Define comprehensive interfaces in `types.ts`
- Use descriptive property names
- Include optional properties where appropriate
- Use union types for variant data

### Data Transformation

- Use utility functions for data formatting
- Implement consistent date formatting
- Handle text sanitization and truncation
- Use proper JSON serialization

## Security Considerations

### API Keys

- Never hardcode API keys
- Use environment variables for sensitive data
- Validate API responses
- Implement proper error handling for auth failures

### Data Privacy

- Sanitize job descriptions before processing
- Handle personal information carefully
- Use secure storage for sensitive data
- Implement proper data retention policies

## Best Practices

### Code Organization

- Keep functions small and focused
- Use descriptive variable names
- Add comments for complex logic
- Follow the single responsibility principle

### Performance

- Implement proper caching strategies
- Use efficient algorithms
- Minimize external API calls
- Process data in batches

### Maintainability

- Write self-documenting code instead of writing comments
- Use consistent patterns throughout
- Keep dependencies minimal

Remember: This project prioritizes reliability, maintainability, and clear separation of concerns.
Always consider error handling, rate limiting, and proper TypeScript typing in your implementations.
